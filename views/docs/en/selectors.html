<!DOCTYPE html><html><head><meta charset="utf-8"><title>selectors-stylus's doc</title><link href="/assets/styles/normalize.css" rel="stylesheet" type="text/css"><link href="/assets/styles/reset.css" rel="stylesheet" type="text/css"><link href="/assets/styles/style.css" rel="stylesheet" type="text/css"></head><body><div id="container"><hr/>

<hr/>

<h1>Selectors</h1>

<h2>Indentation</h2>

<p>Stylus is &quot;pythonic&quot; (i.e. indentation-based). Whitespace is significant, so we substitute <code>{</code> and <code>}</code> with an <em>indent</em>, and an <em>outdent</em> as shown below:</p>

<pre><code>body
  color white</code></pre>

<p>Which compiles to:</p>

<pre><code>body {
  color: #fff;
}</code></pre>

<p>If preferred, you can use colons to separate properties and values:</p>

<pre><code>body
  color: white</code></pre>

<h2>Rule Sets</h2>

<p>Stylus, just like CSS, allows you to define properties for several selectors at once through comma separation.</p>

<pre><code>textarea, input
  border 1px solid #eee</code></pre>

<p>The same can be done with a newline:</p>

<pre><code>textarea
input
  border 1px solid #eee</code></pre>

<p>Both compile to:</p>

<pre><code>textarea,
input {
  border: 1px solid #eee;
}</code></pre>

<p><strong>The only exception to this rule</strong> are selectors that look like properties. For example, the following <code>foo bar baz</code> might be a property <strong>or</strong> a selector:</p>

<pre><code>foo bar baz
&gt; input
  border 1px solid</code></pre>

<p>So for this reason (or simply if preferred), we may trail with a comma:</p>

<pre><code>foo bar baz,
form input,
&gt; a
  border 1px solid</code></pre>

<h2>Parent Reference</h2>

<p>The <code>&amp;</code> character references the parent selector(s). In the example below our two selectors (<code>textarea</code> and <code>input</code>) both alter the <code>color</code> on the <code>:hover</code> pseudo selector. </p>

<pre><code>textarea
input
  color #A7A7A7
  &amp;:hover
    color #000</code></pre>

<p>Compiles to:</p>

<pre><code>textarea,
input {
  color: #a7a7a7;
}
textarea:hover,
input:hover {
  color: #000;
}</code></pre>

<p>Below is an example providing a simple <code>2px</code> border for Internet Explorer utilizing the parent reference within a mixin:</p>

<pre><code>  box-shadow()
    -webkit-box-shadow arguments
    -moz-box-shadow arguments
    box-shadow arguments
    html.ie8 &amp;,
    html.ie7 &amp;,
    html.ie6 &amp;
      border 2px solid arguments[length(arguments) - 1]

  body
    #login
      box-shadow 1px 1px 3px #eee</code></pre>

<p>Yielding:</p>

<pre><code>  body #login {
    -webkit-box-shadow: 1px 1px 3px #eee;
    -moz-box-shadow: 1px 1px 3px #eee;
    box-shadow: 1px 1px 3px #eee;
  }
  html.ie8 body #login,
  html.ie7 body #login,
  html.ie6 body #login {
    border: 2px solid #eee;
  }</code></pre>

<p>If you&#39;d need to use the ampersand symbol in a selector without it behaving like a parent reference, you can just escape it:</p>

<pre><code>.foo[title*=&#39;\&amp;&#39;]
// =&gt; .foo[title*=&#39;&amp;&#39;]</code></pre>

<h2>Partial Reference</h2>

<p><code>^[N]</code> anywhere in a selector, where <code>N</code> can be a number, represents a partial reference.</p>

<p>Partial reference works similar to the parent reference, but while parent reference contains the whole selector, partial selectors contain only the first merged <code>N</code> levels of the nested selectors, so you could access those nesting levels individually.</p>

<p>The <code>^[0]</code> would give you the selector from the first level, the <code>^[1]</code> would give you the rendered selector from the second level and so on:</p>

<pre><code>.foo
  &amp;__bar
    width: 10px

    ^[0]:hover &amp;
      width: 20px</code></pre>

<p>would be rendered as</p>

<pre><code>.foo__bar {
  width: 10px;
}
.foo:hover .foo__bar {
  width: 20px;
}</code></pre>

<p>Negative values are counting from the end, so ^[-1] would give you the last selector from the chain before <code>&amp;</code>:</p>

<pre><code>.foo
  &amp;__bar
    &amp;_baz
      width: 10px

      ^[-1]:hover &amp;
        width: 20px</code></pre>

<p>would be rendered as</p>

<pre><code>.foo__bar_baz {
  width: 10px;
}
.foo__bar:hover .foo__bar_baz {
  width: 20px;
}</code></pre>

<p>Negative values are especially helpful for usage inside mixins when you don&#39;t know at what nesting level you&#39;re calling it.</p>

<hr/>

<p>Note that partial reference contain the whole rendered chain of selectors until the given nesting level, not the “part” of the selector.</p>

<h3>Ranges in partial references</h3>

<p><code>^[N..M]</code> anywhere in a selector, where both <code>N</code> and <code>M</code> can be numbers, represents a partial reference.</p>

<p>If you&#39;d have a case when you&#39;d need to get the raw part of the selector, or to get the range of parts programmatically, you could use ranges inside partial reference.</p>

<p>If the range would start from the positive value, the result won&#39;t contain the selectors of the previous levels and you&#39;d get the result as if the selectors of those levels were inserted at the root of the stylesheet with the combinators omitted:</p>

<pre><code>.foo
  &amp; .bar
    width: 10px

    ^[0]:hover ^[1..-1]
      width: 20px</code></pre>

<p>would be rendered as</p>

<pre><code>.foo .bar {
  width: 10px;
}
.foo:hover .bar {
  width: 20px;
}</code></pre>

<p>One number in the range would be the start index, the second — the end index. Note that the order of those numbers won&#39;t matter as the selectors would always render from the first levels to the last, so <code>^[1..-1]</code> would be equal to the <code>^[-1..1]</code>.</p>

<p>When both numbers are equal, the result would be just one raw level of a selector, so you could replace <code>^[1..-1]</code> in a previous example to <code>^[-1..-1]</code>, and it would be equal to the same last one raw selector, but would be more reliable if used inside mixins.</p>

<h2>Initial Reference</h2>

<p>The <code>~/</code> characters at the start of a selector can be used to point at the selector at the first nesting and could be considered as a shortcut to <code>^[0]</code>. The only drawback is that you can use initial reference only at the start of a selector:</p>

<pre><code>.block
  &amp;__element
    ~/:hover &amp;
      color: red</code></pre>

<p>Would be rendered as</p>

<pre><code>.block:hover .block__element {
  color: #f00;
}</code></pre>

<h2>Relative Reference</h2>

<p>The <code>../</code> characters at the start of a selector mark a relative reference, which points to the previous to the <code>&amp;</code> compiled selector. You can nest relative reference: <code>../../</code> to get deeper levels, but note that it can be used only at the start of the selector.</p>

<pre><code>.foo
  .bar
    width: 10px

    &amp;,
    ../ .baz
      height: 10px</code></pre>

<p>would be rendered as</p>

<pre><code>.foo .bar {
  width: 10px;
}
.foo .bar,
.foo .baz {
  height: 10px;
}</code></pre>

<p>Relative references can be considered as shortcuts to the partial references with ranges like <code>^[0..-(N + 1)]</code> where the <code>N</code> is the number of relative references used.</p>

<h2>Root Reference</h2>

<p>The <code>/</code> character at the start of a selector is a root reference. It references the root context and this means the selector won&#39;t prepend the parent&#39;s selector to it (unless you would use it with <code>&amp;</code>). It is helpful when you need to write some styles both to some nested selector and to another one, not in the current scope.</p>

<pre><code>textarea
input
  color #A7A7A7
  &amp;:hover,
  /.is-hovered
    color #000</code></pre>

<p>Compiles to:</p>

<pre><code>textarea,
input {
  color: #a7a7a7;
}
textarea:hover,
input:hover,
.is-hovered {
  color: #000;
}</code></pre>

<h2>selector() bif</h2>

<p>You can use the built-in <code>selector()</code> to get the current compiled selector. Could be used inside mixins for checks or other clever things.</p>

<pre><code>.foo
  selector()
// =&gt; &#39;.foo&#39;

.foo
  &amp;:hover
    selector()
// &#39;.foo:hover&#39;</code></pre>

<p>This bif could also accept an optional string argument, in this case it would return the compiled selector. Note that it wouldn&#39;t prepend the selector of the current scope in case it don&#39;t have any <code>&amp;</code> symbols.</p>

<pre><code>.foo
  selector(&#39;.bar&#39;)
// =&gt; &#39;.bar&#39;

.foo
  selector(&#39;&amp;:hover&#39;)
// &#39;.foo:hover&#39;</code></pre>

<h3>Multiple values for <code>selector()</code> bif</h3>

<p><code>selector()</code> bif can accept multiple values or a comma-separated list in order to create a nested selector structure easier.</p>

<pre><code>{selector(&#39;.a&#39;, &#39;.b&#39;, &#39;.c, .d&#39;)}
  color: red</code></pre>

<p>would be equal to the</p>

<pre><code>.a
  .b
    .c,
    .d
      color: red</code></pre>

<p>and would be rendered as</p>

<pre><code>.a .b .c,
.a .b .d {
  color: #f00;
}</code></pre>

<h2>selectors() bif</h2>

<p>This bif returns a comma-separated list of nested selectors for the current level:</p>

<pre><code>.a
  .b
    &amp;__c
      content: selectors()</code></pre>

<p>would be rendered as</p>

<pre><code>.a .b__c {
  content: &#39;.a&#39;, &#39;&amp; .b&#39;, &#39;&amp;__c&#39;;
}</code></pre>

<h2>Disambiguation</h2>

<p>Expressions such as <code>margin - n</code> could be interpreted both as a subtraction operation, as well as a property with an unary minus. To disambiguate, wrap the expression with parens:</p>

<pre><code>pad(n)
  margin (- n)

body
  pad(5px)</code></pre>

<p>Compiles to:</p>

<pre><code>body {
  margin: -5px;
}</code></pre>

<p>However, this is only true in functions (since functions act both as mixins, or calls with return values). </p>

<p>For example, the following is fine (and yields the same results as above):</p>

<pre><code>body
  margin -5px</code></pre>

<p>Have weird property values that Stylus can&#39;t process? <code>unquote()</code> can help you out:</p>

<pre><code>filter unquote(&#39;progid:DXImageTransform.Microsoft.BasicImage(rotation=1)&#39;)</code></pre>

<p>Yields:</p>

<pre><code>filter progid:DXImageTransform.Microsoft.BasicImage(rotation=1)</code></pre></div></body></html>